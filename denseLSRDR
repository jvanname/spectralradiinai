# Here, aa will be a list of matrices. bb will be trained by gradient ascent to converge to an LSRDR of aa. To run the code just copy and paste into Julia.

using Statistics,LinearAlgebra;

n=50;
d=20;
k=10;
aa=randn(ComplexF64,k,n,n);;
bb=Array{ComplexF64,3}(undef,k,d,d);;
rr=randn(ComplexF64,d,n);;
ss=randn(ComplexF64,n,d);;
for i in 1:k
bb[i,:,:]=rr*aa[i,:,:]*ss;
end;

#function topsuper(aa,rr,ss)
#cc=kron(aa[1],adjoint(transpose(rr*aa[1]*ss)));
#for i in 2:k
#cc+=kron(aa[i],adjoint(transpose(rr*aa[i]*ss)));
#end;
#return log(rad(cc));
#end;

#function bottomsuper(aa,rr,ss)
#cc=kron(rr*aa[1]*ss,adjoint(transpose(rr*aa[1]*ss)));
#for i in 2:k
#cc+=kron(rr*aa[i]*ss,adjoint(transpose(rr*aa[i]*ss)));
#end;
#return log(rad(cc));
#end;

#function super(aa,rr,ss)
#return topsuper(aa,rr,ss)-bottomsuper(aa,rr,ss)/2; 
#end;

#u=randn(ComplexF64,n,d);
#v=randn(ComplexF64,n,d);

#ubot=randn(ComplexF64,d,d);
#vbot=randn(ComplexF64,d,d);


#lambda=0;
#for iak in 1:10000
#newu=u*0;
#newv=v*0;
#for i in 1:k
#newv+=aa[i]*v*adjoint(bb[i]);
#newu+=adjoint(aa[i])*u*bb[i];
#end;
#lambda=dot(v,newv);
#u=newu/norm(newu);
#v=newv/norm(newv);
#end;

#lambdabot=0;
#for iak in 1:10000
#newu=ubot*0;
#newv=vbot*0;
#for i in 1:k
#newv+=bb[i]*vbot*adjoint(bb[i]);
#newu+=adjoint(bb[i])*ubot*bb[i];
#end;
#lambdabot=dot(vbot,newv);
#ubot=newu/norm(newu);
#vbot=newv/norm(newv);
#end;


#function rad(x) return maximum(abs.(eigvals(x))); end;
 
#function sr(aa,bb)
#cc=kron(aa[1],adjoint(transpose(bb[1])));
#for i in 2:k
#cc+=kron(aa[i],adjoint(transpose(bb[i])));
#end;
#return log(rad(cc));
#end;
 
#gradient(sr,aa,bb)[1][1]-u*bb[1]*adjoint(v)*dot(u,v)*lambda/abs(dot(u,v)*lambda)^2;
#gradient(sr,aa,bb)[2][1]-adjoint(u)*aa[1]*v*adjoint(lambda)*dot(v,u)/abs(lambda*dot(v,u))^2;

#rrgrad=rr*0;
#ssgrad=ss*0;

#for i in 1:k
#rrgrad+=adjoint(u)*aa[i]*v*adjoint(lambda)*dot(v,u)/abs(lambda*dot(v,u))^2*adjoint(aa[i]*ss);
#ssgrad+=adjoint(rr*aa[i])*adjoint(u)*aa[i]*v*adjoint(lambda)*dot(v,u)/abs(lambda*dot(v,u))^2;

#rrgrad-=ubot*bb[i]*adjoint(vbot)*dot(ubot,vbot)*lambdabot/abs(dot(ubot,vbot)*lambdabot)^2*adjoint(aa[i]*ss);
#ssgrad-=adjoint(rr*aa[i])*ubot*bb[i]*adjoint(vbot)*dot(ubot,vbot)*lambdabot/abs(dot(ubot,vbot)*lambdabot)^2;

#### The following two lines are turned off since they are equal to the above two lines.
#####rrgrad+=adjoint(ubot)*bb[i]*vbot*adjoint(lambdabot)*dot(vbot,ubot)/abs(lambdabot*dot(vbot,ubot))^2*adjoint(aa[i]*ss);
#####ssgrad+=adjoint(rr*aa[i])*adjoint(ubot)*bb[i]*vbot*adjoint(lambdabot)*dot(vbot,ubot)/abs(lambdabot*dot(vbot,ubot))^2;
#end;

#gradient(super,aa,rr,ss)[2]-rrgrad;
#gradient(super,aa,rr,ss)[3]-ssgrad;


toplefteigvec=randn(ComplexF64,n,d);
toprighteigvec=randn(ComplexF64,n,d);
bottomlefteigvec=randn(ComplexF64,d,d);
bottomrighteigvec=randn(ComplexF64,d,d);

rate=.8;
grad=zeros(ComplexF64,k,d,d);
pp=0;
qq=0;
while true
 newtoplefteigvec=toplefteigvec*0;
 newtoprighteigvec=toprighteigvec*0;
 newbottomlefteigvec=bottomlefteigvec*0;
 newbottomrighteigvec=bottomrighteigvec*0;
 for i in 1:k
 newtoplefteigvec+=adjoint(aa[i,:,:])*toplefteigvec*bb[i,:,:];
 newtoprighteigvec+=aa[i,:,:]*toprighteigvec*adjoint(bb[i,:,:]);
 newbottomlefteigvec+=adjoint(bb[i,:,:])*bottomlefteigvec*bb[i,:,:];
 newbottomrighteigvec+=bb[i,:,:]*bottomrighteigvec*adjoint(bb[i,:,:]);
 end;
 toplambda=dot(toprighteigvec,newtoprighteigvec);
 bottomlambda=dot(bottomrighteigvec,newbottomrighteigvec);
 #The following two lines of code are needed if we want the average of the toplefteigvec and 
 # toprighteigvec to be zero. This is useful for cryptography applications.
 #newtoplefteigvec-=ones(n)*(adjoint(ones(n))*(newtoplefteigvec/n));
 #newtoprighteigvec-=ones(n)*(adjoint(ones(n))*(newtoprighteigvec/n));
 toplefteigvec=newtoplefteigvec/norm(newtoplefteigvec);
 toprighteigvec=newtoprighteigvec/norm(newtoprighteigvec);
 bottomlefteigvec=newbottomlefteigvec/norm(newbottomlefteigvec);
 bottomrighteigvec=newbottomrighteigvec/norm(newbottomrighteigvec);
 grad*=0.95;
 for i in 1:k
grad[i,:,:]+=0.05*adjoint(toplefteigvec)*aa[i,:,:]*toprighteigvec*adjoint(toplambda)*dot(toprighteigvec,toplefteigvec)/abs(toplambda*dot(toprighteigvec,toplefteigvec))^2;
 grad[i,:,:]-=0.05*bottomlefteigvec*bb[i,:,:]*adjoint(bottomrighteigvec)*dot(bottomlefteigvec,bottomrighteigvec)*bottomlambda/abs(dot(bottomlefteigvec,bottomrighteigvec)*bottomlambda)^2;
#The following line is commented since it is equal to the above line.
#grad[i]- =0.05*adjoint(bottomlefteigvec)*bb[i,:,:]*bottomrighteigvec*adjoint(bottomlambda)*dot(bottomrighteigvec,bottomlefteigvec)/abs(bottomlambda*dot(bottomrighteigvec,bottomlefteigvec))^2;
 end;

 bb+=rate*grad;

 bb/=norm(bb);
 qq=pp;
 pp=log(abs(toplambda/bottomlambda^(1/2)));
 display([pp,rate]);
 if pp==qq break; end;
end;

##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################

toplefteigvec=randn(ComplexF64,n,d);
toprighteigvec=randn(ComplexF64,n,d);
bottomlefteigvec=randn(ComplexF64,d,d);
bottomrighteigvec=randn(ComplexF64,d,d);
rr=randn(ComplexF64,d,n);
ss=randn(ComplexF64,n,d);

rrgrad=rr*0;
ssgrad=ss*0;

rate=.5;
pp=0;
qq=-20;
while true
newtoplefteigvec=toplefteigvec*0;
newtoprighteigvec=toprighteigvec*0;

newbottomlefteigvec=bottomlefteigvec*0;
newbottomrighteigvec=bottomrighteigvec*0;

for i in 1:k
newtoplefteigvec+=adjoint(aa[i,:,:])*toplefteigvec*bb[i,:,:];
newtoprighteigvec+=aa[i,:,:]*toprighteigvec*adjoint(bb[i,:,:]);
newbottomlefteigvec+=adjoint(bb[i,:,:])*bottomlefteigvec*bb[i,:,:];
newbottomrighteigvec+=bb[i,:,:]*bottomrighteigvec*adjoint(bb[i,:,:])
end;
toplambda=dot(toprighteigvec,newtoprighteigvec);
bottomlambda=dot(bottomrighteigvec,newbottomrighteigvec);

toplefteigvec=newtoplefteigvec/norm(newtoplefteigvec);
toprighteigvec=newtoprighteigvec/norm(newtoprighteigvec);
bottomlefteigvec=newbottomlefteigvec/norm(newbottomlefteigvec);
bottomrighteigvec=newbottomrighteigvec/norm(newbottomrighteigvec);

# I have verified that the eigenvectors and eigenvalues are good.

#slowgrad=gradient(sr,aa,bb)[2]-sum(gradient(sr,bb,bb))/2;

rrgrad*=0.95;
ssgrad*=0.95;

for i in 1:k
rrgrad+=0.05*adjoint(toplefteigvec)*aa[i,:,:]*toprighteigvec*adjoint(toplambda)*dot(toprighteigvec,toplefteigvec)/abs(toplambda*dot(toprighteigvec,toplefteigvec))^2*adjoint(aa[i,:,:]*ss);
ssgrad+=0.05*adjoint(rr*aa[i,:,:])*adjoint(toplefteigvec)*aa[i,:,:]*toprighteigvec*adjoint(toplambda)*dot(toprighteigvec,toplefteigvec)/abs(toplambda*dot(toprighteigvec,toplefteigvec))^2;

rrgrad-=0.05*bottomlefteigvec*bb[i,:,:]*adjoint(bottomrighteigvec)*dot(bottomlefteigvec,bottomrighteigvec)*bottomlambda/abs(dot(bottomlefteigvec,bottomrighteigvec)*bottomlambda)^2*adjoint(aa[i,:,:]*ss);
ssgrad-=0.05*adjoint(rr*aa[i,:,:])*bottomlefteigvec*bb[i,:,:]*adjoint(bottomrighteigvec)*dot(bottomlefteigvec,bottomrighteigvec)*bottomlambda/abs(dot(bottomlefteigvec,bottomrighteigvec)*bottomlambda)^2;
end;

#display([gradient(super,aa,rr,ss)[2]-rrgrad,gradient(super,aa,rr,ss)[3]-ssgrad])

rr+=rate*rrgrad;
ss+=rate*ssgrad;

rr/=norm(rr);
ss/=norm(ss);

for i in 1:k
bb[i,:,:]=rr*aa[i,:,:]*ss;
end;

qq=pp;
pp=log(abs(toplambda/bottomlambda^(1/2)));
display([pp,rate]);
end;

##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################


