n=1000;
d=10;

ll=100;

list=[];
for i in 1:ll
push!(list,[]);
for j in 1:n
if rand(0:10)==0 push!(list[i],j); end;
end;
end;

vectors=[];
for i in 1:n
push!(vectors,randn(type,d));
end;

function topscore(list,vectors)
cc=0;
for i in 1:ll
dd=zeros(type,d);
for a in list[i]
dd+=vectors[a];
end;
cc+=log(norm(dd));
end;
return cc/ll;
end;

function bottomscore(multiplicity,vectors)
mat=zeros(type,d,d);
for i in 1:n
mat+=multiplicity[i]*vectors[i]*adjoint(vectors[i]);
end;
return log(norm(mat))/2;
end;

function gradtopscore(list,vectors)
grad=[];
for i in 1:n
push!(grad,zeros(type,d));
end;
for i in 1:ll
dd=zeros(type,d);
for a in list[i]
dd+=vectors[a];
end;
for a in list[i]
grad[a]+=dd/norm(dd)^2;
end;
end;
return grad/ll;
end;

score=function(multiplicity,list,vectors)
return topscore(list,vectors)-bottomscore(multiplicity,vectors);
end;

function gradbottomscore(multiplicity,vectors)
grad=[];
for i in 1:n
push!(grad,zeros(type,d));
end;
cc=zeros(type,d,d);
for i in 1:n
cc+=multiplicity[i]*vectors[i]*adjoint(vectors[i]);
end;
mash=[];
for i in 1:n
push!(mash,cc*multiplicity[i]*vectors[i]);
end;
return mash/norm(cc)^2;
end;

function gradscore(multiplicity,list,vectors)
return gradtopscore(list,vectors)-gradbottomscore(multiplicity,vectors);
end;

type=Float64;

vectors=[];

ll=length(list);
n=maximum(maximum.(list));


multiplicity=zeros(n);
for i in 1:ll
ccq=1/length(list[i]);
for a in list[i]
multiplicity[a]+=1/ccq;
end;
end;

for i in 1:n
push!(vectors,randn(type,d));
end;
grad=vectors*0;
pp=1;
qq=1;
while true
rate=rate*1.05;
grad=0.95*grad+0.05*gradscore(multiplicity,list,vectors);
vectors/=mean(norm.(vectors));
vectors+=rate*grad;
pp=score(multiplicity,list,vectors);
display([pp,rate]);
if qq>pp rate*=0.5; end;
qq=pp;
end;
