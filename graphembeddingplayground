# Here we give examples of graph embeddings constructed using ideas similar to L_{2,d}-spectral radius dimensionality reduction.

# I am going to have to write the code for when the matrix is factored as a product of low rank matrices.

#gradient(g,x,y)[1]-adjoint(u)*adjoint(v)*(u*v)*lambda/abs(u*v*lambda)^2*adjoint(y)

list=[];
type=Float64;
n=30;
nn=Int(n/2);
d=40;
power=2;

for i in 1:n
push!(list,[]);
end;
for i in 1:n
for j in 1:(i-1)
if rand(0:1)==1
push!(list[i],j);
push!(list[j],i);
end;
end;
end;

ll=sum(length.(list));

matscore=function(matrix)
prod=0;
suma=zeros(d,d);
for i in 1:n
suma+=matrix[i]*adjoint(matrix[i]);
for a in list[i]
prod+=log(norm((matrix[a]*matrix[i])^power));
end;
end;
return exp(prod/(ll*2*power))/norm(suma);
end;

score=function(leftarray,rightarray)
prod=0;
suma=zeros(d,d);
for i in 1:n
suma+=leftarray[i]*adjoint(leftarray[i])+rightarray[i]*adjoint(rightarray[i]);
for a in list[i]
prod+=log(abs(dot(leftarray[i],rightarray[a])));
end;
end;
return exp(prod/ll)/norm(suma);
end;
qq=0;
rate=.3;

matrixtable=[];
leftarray=[];
rightarray=[];
for i in 1:n
push!(matrixtable,randn(type,d,d));
push!(leftarray,randn(type,d,d));
push!(rightarray,randn(type,d,d));
end;


rate=1;
pp=1;
qq=1;
amm=0;
while true
grad=gradient(matscore,matrixtable)[1];
matrixtable=matrixtable+rate*grad;
matrixtable/=mean(norm.(matrixtable));
pp=matscore(matrixtable);
amm=amm*0.99+0.01*(pp-qq);
display([rate,pp,(pp-qq)/amm]);
if qq>pp rate/=2;
end;
rate*=1.01;
qq=pp;
end;


rate=1;
pp=1;
qq=1;
amm=0;
while true
grad=gradient(score,leftarray,rightarray);
leftarray+=rate*grad[1];
rightarray+=rate*grad[2];
amm=norm(leftarray);
leftarray/=amm;
rightarray/=amm;
pp=score(leftarray,rightarray);
amm=amm*0.99+0.01*(pp-qq);
display([rate,pp,(pp-qq)/amm]);
#if qq>pp rate/=2;
#end;
#rate*=1.01;
qq=pp;
end;


